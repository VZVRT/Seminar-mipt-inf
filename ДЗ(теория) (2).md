	ДЗ 1 (Теория)
	Вопрос 1: Что такое граф?
Граф- это структура данных, представляющая собой совокупность так называемых вершин и рёбер (пример:дороги между городами). Графы классифицируются несколькими способами. К примеру, взвешенные и невзвешенные; ориентированные и неориентированные. Здесь взвешенные имеют определённый вес,  а невзвешенные имеют одинаковый между собой вес; ориентированнные имеют направление от вершины к вершине, а неориентированные, соответственно, нет. 

	Вопрос 2: В случае простого графа (отсутствуют петли и кратные ребра), какое максимальное возможное количество ребер M? Зависит ли это число от ориентированности графа?
В случае  отсутствия кратных рёбер и петель выполняется, что вершина не может взаимодействовать сама с собой и в каждую из оставшихся вершин (N-1, где N- количество вершин) из неё может вести не более одного ребра. Тогда можно сказать, что M<=N(N-1)/2. Делим на два, так как мы учли каждое ребро по два раза. 
Пусть теперь граф будет ориентирован. Тогда ограничение для M: M<=N(N-1), так как для любых двух вершин можно будет провести два ребра, в одну и другую сторону.

	Вопрос 3: Как по заданной матрице смежности быстро проверить граф на ориентированность?
Пусть граф неориентирован. Тогда для любых двух вершин справедливо, что если ребро идёт из первой во вторую, то оно идёт и из второй в первую. Учитывая структуру матрицы смежности, можно сказать, что в случае неориентированного графа матрица будет симметрична относительно транспонирования. В противном случае получаем ориентированный граф.

	Вопрос 4: Как изменятся структуры списка ребер и списка смежности в случае взвешенного графа?
В случае невзвешенного графа в списке рёбер хранится только набор пар вершин, соединённых одним ребром, но если граф будет взвешенным, то нужно будет добавить к каждой паре значение веса ребра, их соединяющего.
В случае невзвешенного графа в списке смежности в качестве ключей хранятся вершины, а в качестве значений- списки их соседей. Аналогично предыдущему добавим к каждой из соседних вершин значение веса ребра до неё. Представить это можно, например, кортежем внутри списка, представляющего собой значение какого-нибудь ключа, где теперь будет записана не только сама вершина, но и вес ребра до неё.

	Вопрос 5: Что такое компонента связности графа? Каким может быть максимальное и минимальное кол-во компонент в одном графе?
Можно сказать, что компонента связности- это максимальный связный подграф в исходном графе, то есть максимальное количество вершин, между которыми существует путь.
В одном графе количество компонент связности может пробегать значения от 1 до N. Например, если граф связный, то из любой вершины можно дойти в другую. Отсюда следует, что в графе всего одна компонента связности. Обратный случай, никакая вершина не связана с другой, но тогда каждая вершина будет отдельной компонентой связности, значит их количество будет равно N.

	Вопрос 6: Можно ли с помощью BFS искать циклы в графе? Выгоднее ли это чем поиск через DFS?
Искать циклы в графе можно обоими методами по алгоритму "белое-серое-чёрное". В конечном итоге мы найдём цикл и таким, и таким способом, потому что при наличии цикла в любом случае "воткнёмся" в "чёрную" вершину. Другой вопрос, выгода. Оба алгоритма работают за одно время, но BFS более затратен по памяти, так как он хранит все узлы в очереди, а в DFS используется стек, что делает его более экономным в плане памяти.

	Вопрос 7: Зачем вводится требование на неотрицательность веса ребра в алгоритме Дейкстры? Можно ли заставить алгоритм корректно работать в случае отрицательных весов (без их изменения).
Алгоритм предназачен для поиска кратчайшего расстояния от выбранной вершины до всех остальных в графе. Суть заключается в том, что он каждый раз ищет вершину с минимальным весом ребра до неё, а потом обновляет расстояния от неё до соседних вершин (которые в начале мы можем задать, например, inf). Если случится так, что в графе будут отрицательные рёбра, может произойти ситуация, когда мы найдём более выгодный путь к вершине, которую мы уже отметили однозначно определённой (выяснили однозначный минимальный путь до этой вершины). 
Отсюда следует, что алгоритм Дейкстры не может работать с отрицательными весами. Попытка оптимизировать алгоритм для работы с отрицательными рёбрами приведёт к изменению основной идеи алгоритма (хотя в теории можно добавить ко всем рёбрам очень большое положительное число, а после определения пути вычесть добавку, делённую на количество шагов, но этот вариант значительно испортит ассимптотику).

	Вопрос 8: Зачем запускать алгоритм Форда-Беллмана в N-й раз? Почему в определенных случаях задача поиска кратчайщего пути в принципе некорректна на нашем графе?
Задача может быть некорректна в случае, если в графе есть цикл с отрицательным суммарным весом (по крайней мере для вершин, в которые мы можем прийти из этого цикла). Можно бесконечно проходить по нему и делать сумму всё меньше и меньше, но тогда мы никогда из него не выйдем. Из-за этого может сломаться вся задача поиска минимального пути. Также можно выделить случай недостижимости вершин из-за отсутвия рёбер, ведущих к ним.
Исходя из принципа работы алгоритма Форда-Беллмана за минимальное для M число запусков алгоритма, которое равно N-1, мы однозначно можем определить кратчайшее расстояние до вершин. Но если мы запустим алгоритм в N-й раз и из-за этого хоть один вес уменьшится, то это будет значить, что в графе есть отрицательный цикл, так как до этого мы отрелаксировали все рёбра, то есть учли потенциально возможные положительные цикла и обошли их, тем самым нашли кратчайшее расстояние за N-1 запуск.

	Вопрос 9: Подумайте, в каком случае Форд-Беллман может работать быстрее чем Дейкстра. Каким образом можно оптимизировать эту ситуацию?
В целом Ф.-Б. проигрывает Дейкстре по времени. Но он может работать быстрее в ситуации, когда граф разрежен (при ассимптотике О(N*M)) мы получаем O(N^2) (M пропорционально N), как и в Дейкстре. Но при этом костанта в алгоритме Ф.-Б. меньше, так как код проще, следовательно, в данном случае Ф.-Б. выгоднее Дейкстры. 
В некоторых случаях, наверное, можно совместить эти два алгоритма и получить выигрыш по времени.

	Вопрос 10: В каких ситуациях вы предпочтете рекурсивную реализацию DFS итеративной и наоборот? Эффективно ли применение списка в качестве стэка в итеративной версии? Что насчет очереди в случае BFS?
Понятно, что рекурсивное написание будет проще, но на больших объёмах данных использовать её неоптимально, так как перегрузится стек вызовов, поэтому в таком случае нужно выбирать итеративный вариант.
Применение стэка в итеративной версии будет эффективным, если использовать вставку и удаление в конце списка. Список может динамически изменять свой размер, что уменьшает вероятность переполнения стека. Также он хорошо работает с методами "pop" и "append".
В случае BFS следует использовать очередь, так как тогда элементы будут обрабатываться в порядке добавления, а на этом и основан принцип работы BFS.